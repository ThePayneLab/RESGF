#========================================================================
# Classes ####
#========================================================================

#' @export
print.resgfStatus <-
          function(object,n=NULL) {
            cat(sprintf("%-30s : %s\n","Local directory",attr(object,"local.dir")))
            cat(sprintf("%-30s : %s\n","Checksums verified?",attr(object,"checksums.verified")))
            cat(sprintf("%-30s : %i\n","Remote files",nrow(object)))
            cat(sprintf("%-30s : %i\n","Valid local files",
                         sum(object$locally.valid)))
            if(attr(object,"checksums.verified")) {
            cat(sprintf("%-30s : %i\n","Local checksums passed",
                        sum(object$checksum.passed,na.rm = TRUE)))}
            object %>%
              as_tibble() %>%
              print(n=n)
          }

#' @export
is.resgfStatus <- function(x) inherits(x, "resgfStatus")

#========================================================================
# Perform check ####
#========================================================================

#' Compare local database with ESGF search
#'
#' Compares the list of files generated by an ESGF search with the locally downloaded files
#'
#' @param local.dir Path to the local directory. Files nested in subdirectories are also detected.
#' @param remote.db resgfFileset object generated previously, which forms the reference database. Alternatively, another
#' resgfStatus object that we wish to recheck.
#' @param check.checksums Should the comparison be done using the checksums (slow!)? Or only the filenames.
#' @param processes Number of processes to run in parallel
#'
#' @return An resgfStatus object
#' @export
#'
#' @examples
#' resgf_status_check(local.db.dir=pwd(),
#'                    esgf.manifest=this.manifest)
resgf_status_check <-
  function(local.dir,
           remote.db,
           check.checksums=FALSE,
           processes=1) {
    #Check inputs
    assert_that(is.resgfFileset(remote.db) | is.resgfStatus(remote.db),
                msg="'remote.db' argument needs to be of type resgfFileset or resgfStatus.")
    if(is.resgfStatus(remote.db)) {
      remote.db <- 
        remote.db %>%
        select(-local.path,-filename,-checksum.passed)
    }

    #Get list of files already existing in database
    local.db <-
      tibble(local.path=dir(local.dir,full.names=TRUE,pattern="*.nc",recursive=TRUE)) %>%
      mutate(filename=basename(local.path)) %>%
      relocate(filename,.before=1)

    #Merge with remote database
    status.db <-
      remote.db %>%
      as_tibble() %>%
      mutate(filename=title)%>%
      right_join(x=local.db,by="filename") 
    
    #Add check for zero file size
    status.db <-
      status.db %>%
      mutate(locally.valid=map_if(local.path,!is.na(local.path),~file.size(.x)!=0,.else=~FALSE),
             locally.valid=map_lgl(locally.valid,~.x))

    #Here we would do the checksum check
    if(check.checksums) {
      #Best if we do it via pblapply, to allow parallelisation. This requires
      #first separating out the files to checksum, doing the analysis, and then recombining
      #Obviously only check the files that we have locally
      check.these <-
        status.db %>%
        filter(locally.valid) %>%
        select(filename,local.path,id,checksum,checksum_type) %>%
        split(.,seq(nrow(.)))   #Split into individual rows for pbapply

      #Now do the checking
      check.status <-
        pblapply(check.these,cl=processes,FUN=function(d) {
          d$checksum.passed <-
            switch(d$checksum_type,
                 "SHA256"=system(sprintf("echo %s %s | sha256sum --check",d$checksum,d$local.path),
                                 ignore.stderr = TRUE,ignore.stdout = TRUE),
                 stop(sprintf("Unsupport checksum_type %s needed for file %s",d$checksum_type,d$local.path)))
          return(d)
        }) %>%
        bind_rows() %>%
        mutate(checksum.passed=checksum.passed==0)

      #Merge results back into table
      status.db <-
        check.status %>%
        select(id,checksum.passed) %>%
        left_join(x=status.db,by="id")

    } else {
    status.db <-
          mutate(status.db,
                 checksum.passed=FALSE)
    }

    #Return status object
    rtn <- new_tibble(status.db,
                      nrow=nrow(status.db),
                      class="resgfStatus",
                      local.dir=local.dir,
                      checksums.verified=check.checksums)

    return(rtn)
  }

#========================================================================
# Helpers ####
#========================================================================

#' Summarise status
#'
#' Summarise the results stored in a resgfStatus object in terms of one of the filename fields or the data node
#'
#' @param object An resgfStatus object
#' @param field.idx Index of the filename field to summarise over.
#' @param field.sep  Character used to separate fields in the filename. Default is "_"
#' @return A tibble summarising the status accordingly.
#' @name summariseStatus
#' @export
#'
resgf_status_by_field <- function(object,field.idx=1,field.sep="_") {
  #Check inputs
  assert_that(is(object,"resgfStatus"),
              msg="Supplied object is not an resgfStatus object")
  assert_that(length(field.idx)==1,
              msg="Field argument must be an integer of length 1")

  #Split filenames into fiels
  this.status <-
    object %>%
    as_tibble() %>%
    mutate(noext.fname=gsub("\\..*?$","",filename),
           field=str_split(noext.fname,field.sep,simplify = TRUE))

  #Check that request is ok
  assert_that(ncol(this.status$field) >= field.idx,
              msg=sprintf("Field index requested, %i, is too high. Max value is %i.",
                          field.idx,ncol(this.status$field)))

  this.status %>%
    mutate(field.value=field[,field.idx]) %>%
    group_by(field.value) %>%
    summarise(remote.files=n(),
              local.files=sum(locally.valid),
              prop=mean(locally.valid),
              checksums.ok=sum(checksum.passed),
              prop.checksums=mean(checksum.passed),
              .groups="drop")

}

#' @export
#' @name summariseStatus
resgf_status_by_node <- function(object) {
  assert_that(is(object,"resgfStatus"),
              msg="Supplied object is not an resgfStatus object")
  object %>%
    group_by(data_node) %>%
    summarise(remote.files=n(),
              local.files=sum(locally.valid),
              prop=mean(locally.valid),
              checksums.ok=sum(checksum.passed),
              prop.checksums=mean(checksum.passed),
              .groups="drop")

}

